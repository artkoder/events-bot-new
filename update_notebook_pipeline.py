import json
from pathlib import Path

NOTEBOOK_PATH = Path("kaggle/CrumpleVideo/crumple_video.ipynb")

NEW_SOURCE = [
    "# ==========================================\n",
    "# 7. ОСНОВНОЙ ПАЙПЛАЙН (Updated for Outro & Cities)\n",
    "# ==========================================\n",
    "\n",
    "def main_pipeline():\n",
    "    \"\"\"Full pipeline.\"\"\"\n",
    "    \n",
    "    payload_path = SOURCE_FOLDER / \"payload.json\"\n",
    "    \n",
    "    # Fallback for missing payload.json\n",
    "    if not payload_path.exists():\n",
    "        log(f\"⚠️ payload.json not found at {payload_path}. Generatng fallback.\")\n",
    "        payload_path = WORKING_DIR / \"payload.json\"\n",
    "        fallback_scenes = []\n",
    "        # Find images in source folder\n",
    "        for ext in [\"*.jpg\", \"*.png\"]:\n",
    "            for img in SOURCE_FOLDER.glob(ext):\n",
    "                fallback_scenes.append({\"image\": img.name, \"text\": f\"Fallback {img.stem}\"})\n",
    "        # Sort and take top 4\n",
    "        fallback_scenes.sort(key=lambda x: x[\"image\"])\n",
    "        fallback_data = {\"scenes\": fallback_scenes[:4]}\n",
    "        with open(payload_path, \"w\") as f:\n",
    "            json.dump(fallback_data, f)\n",
    "        log(f\"✅ Generated fallback payload at {payload_path} with {len(fallback_scenes)} scenes\")\n",
    "    \n",
    "    try:\n",
    "        payload = json.loads(payload_path.read_text())\n",
    "    except Exception as e:\n",
    "        log(f\"❌ Failed to read payload: {e}\")\n",
    "        return False\n",
    "\n",
    "    scenes = payload.get(\"scenes\", [])\n",
    "    \n",
    "    cover_path = WORKING_DIR / \"cover.png\"\n",
    "    cover = payload.get(\"cover\") or {}\n",
    "    cover_date_range = cover.get(\"date_range\") or cover.get(\"dates\") or \"25-27\"\n",
    "    cover_month = cover.get(\"month\") or \"ДЕКАБРЯ\"\n",
    "    cover_title = cover.get(\"title\") or \"ВЫХОДНЫЕ\"\n",
    "    cover_cities = cover.get(\"cities\") or []\n",
    "    \n",
    "    # Generate Cover with Cities\n",
    "    generate_cover_image(cover_date_range, cover_month, cover_path, title=cover_title, cities_list=cover_cities)\n",
    "\n",
    "    posters = [cover_path]\n",
    "    \n",
    "    # Collect scene posters\n",
    "    for i, scene in enumerate(scenes[:12]): # Max 12 as per user spec\n",
    "        # Try to find poster files\n",
    "        # The payload might specify image filename directly\n",
    "        img_name = scene.get(\"image\")\n",
    "        found = None\n",
    "        if img_name:\n",
    "             found = _resolve_image_path(img_name)\n",
    "        \n",
    "        if not found:\n",
    "            # Fallback to posterN naming\n",
    "            for ext in [\".jpg\", \".png\", \".jpeg\"]:\n",
    "                local = SOURCE_FOLDER / f\"poster{i+1}{ext}\"\n",
    "                if local.exists():\n",
    "                    found = local\n",
    "                    break\n",
    "        \n",
    "        if found:\n",
    "            posters.append(found)\n",
    "    \n",
    "    def _resolve_image_path(filename: str):\n",
    "        p = SOURCE_FOLDER / filename\n",
    "        if p.exists(): return p\n",
    "        p = Path(KAGGLE_INPUT_ROOT) / filename\n",
    "        if p.exists(): return p\n",
    "        for base in [SOURCE_FOLDER, Path(KAGGLE_INPUT_ROOT)]:\n",
    "            try:\n",
    "                matches = list(base.rglob(filename))\n",
    "                if matches: return matches[0]\n",
    "            except: pass\n",
    "        return None\n",
    "\n",
    "    # Check for Final scene\n",
    "    final_img = _resolve_image_path(\"Final.png\")\n",
    "    if final_img:\n",
    "        posters.append(final_img)\n",
    "        log(f\"✅ Appended final scene: {final_img}\")\n",
    "    else:\n",
    "        log(\"⚠️ Final.png not found; skipping final scene\")\n",
    "        \n",
    "    log(f\"Posters to render: {len(posters)}\")\n",
    "    \n",
    "    # Build segments\n",
    "    segments = []\n",
    "    \n",
    "    # 1. Intro (Cover) - Starts Flat, Crumples UP (Fold)\n",
    "    # We want Intro to just be visible then crumple away?\n",
    "    # Or start crumpled and uncrumple?\n",
    "    # If stem='frames_0', run_blender_render produced 1..64 (1=Crumpled, 64=Flat).\n",
    "    # Standard flow: Unfold (Ball->Flat) -> Show -> Fold (Flat->Ball).\n",
    "    # Cover usually: Starts Flat (no unfold), Shows, then Folds (to transition to next).\n",
    "    segments.append(SegmentPlan(\n",
    "        stem=\"frames_0\",\n",
    "        unfold_len=0,     # Start Flat\n",
    "        fold_len=24,      # Crumple away\n",
    "        hold_flat=2,\n",
    "        hold_ball=2,\n",
    "        easing_unfold=\"linear\",\n",
    "        easing_fold=\"ease_out_quad\"\n",
    "    ))\n",
    "    \n",
    "    # 2. Main Scenes + Outro\n",
    "    # Iterate posters starting from index 1\n",
    "    for i in range(1, len(posters)):\n",
    "        is_last = (i == len(posters) - 1)\n",
    "        \n",
    "        # If this is the LAST poster (Outro/Final), we want it to Stay Open.\n",
    "        # Unfold -> Hold Flat (Long) -> No Fold\n",
    "        \n",
    "        segments.append(SegmentPlan(\n",
    "            stem=f\"frames_{i}\",\n",
    "            unfold_len=28,\n",
    "            fold_len=0 if is_last else 28,      # No fold for Outro\n",
    "            hold_flat=48 if is_last else 2,     # Hold 2s for Outro\n",
    "            hold_ball=0 if is_last else 2,\n",
    "            easing_unfold=\"ease_in_out_back\",\n",
    "            easing_fold=\"ease_in_out_back\"\n",
    "        ))\n",
    "    \n",
    "    # Render Blender frames\n",
    "    for i, poster in enumerate(posters):\n",
    "        frames_dir = WORKING_DIR / f\"frames_{i}\"\n",
    "        # Check if already rendered (re-entrancy)\n",
    "        if frames_dir.exists() and len(list(frames_dir.glob(\"*.png\"))) >= FRAME_END - FRAME_START:\n",
    "            log(f\"Skipping render for {poster.name} (cached)\")\n",
    "            continue\n",
    "            \n",
    "        success = run_blender_render(poster, frames_dir)\n",
    "        if not success:\n",
    "            log(f\"Skipping poster {i}\")\n",
    "    \n",
    "    # Assemble sequence\n",
    "    log(\"Assembling showreel...\")\n",
    "    sequence = []\n",
    "    \n",
    "    for seg in segments:\n",
    "        frames_dir = WORKING_DIR / seg.stem\n",
    "        frames = load_segment_frames(frames_dir, FRAME_START, FRAME_END)\n",
    "        \n",
    "        if not frames:\n",
    "            log(f\"No frames for {seg.stem}\")\n",
    "            continue\n",
    "        \n",
    "        ball = frames[0]\n",
    "        flat = frames[-1]\n",
    "        \n",
    "        # Unfold (Ball -> Flat)\n",
    "        if seg.unfold_len > 0:\n",
    "            unfold = render_motion(frames, seg.unfold_len, seg.easing_unfold, False, True)\n",
    "            sequence.extend(unfold)\n",
    "        \n",
    "        # Hold Flat\n",
    "        for _ in range(seg.hold_flat):\n",
    "            sequence.append(flat)\n",
    "        \n",
    "        # Fold (Flat -> Ball)\n",
    "        if seg.fold_len > 0:\n",
    "            fold = render_motion(frames, seg.fold_len, seg.easing_fold, True, True)\n",
    "            sequence.extend(fold)\n",
    "        \n",
    "        # Hold Ball\n",
    "        for _ in range(seg.hold_ball):\n",
    "            sequence.append(ball)\n",
    "    \n",
    "    log(f\"Total frames: {len(sequence)}\")\n",
    "    \n",
    "    if not sequence:\n",
    "        log(\"FATAL: No frames!\")\n",
    "        return False\n",
    "    \n",
    "    seq_dir = WORKING_DIR / \"sequence\"\n",
    "    if seq_dir.exists():\n",
    "        import shutil\n",
    "        shutil.rmtree(seq_dir)\n",
    "    seq_dir.mkdir(exist_ok=True)\n",
    "    \n",
    "    for i, frame in enumerate(sequence):\n",
    "        frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n",
    "        cv2.imwrite(str(seq_dir / f\"frame_{i+1:06d}.png\"), frame_bgr)\n",
    "    \n",
    "    video_path = WORKING_DIR / \"crumple_video.mp4\"\n",
    "    render_video_from_frames(seq_dir, video_path, fps=24)\n",
    "    \n",
    "    final_path = WORKING_DIR / \"crumple_video_final.mp4\"\n",
    "    audio_path = list(SOURCE_FOLDER.glob(\"*.mp3\"))\n",
    "    if audio_path:\n",
    "        add_audio(video_path, audio_path[0], final_path)\n",
    "    else:\n",
    "        import shutil\n",
    "        shutil.copy(video_path, final_path)\n",
    "    \n",
    "    if final_path.exists():\n",
    "        size_kb = final_path.stat().st_size / 1024\n",
    "        log(f\"Final video: {size_kb:.1f} KB\")\n",
    "        if size_kb < 500:\n",
    "            log(\"FAIL: Video too small!\")\n",
    "            return False\n",
    "        return True\n",
    "    \n",
    "    return False\n",
    "\n",
    "log(\"=\" * 50)\n",
    "log(\"Starting CrumpleVideo Pipeline\")\n",
    "log(\"=\" * 50)\n",
    "\n",
    "try:\n",
    "    success = main_pipeline()\n",
    "except Exception as e:\n",
    "    import traceback\n",
    "    traceback.print_exc()\n",
    "    success = False\n",
    "\n",
    "if success:\n",
    "    log(\"Pipeline completed!\")\n",
    "else:\n",
    "    log(\"Pipeline failed!\")\n"
]

def main():
    if not NOTEBOOK_PATH.exists():
        print(f"Error: {NOTEBOOK_PATH} not found")
        return

    with open(NOTEBOOK_PATH, "r", encoding="utf-8") as f:
        nb = json.load(f)

    # Find cell
    updated = False
    for cell in nb["cells"]:
        if cell.get("id") == "main-pipeline":
            cell["source"] = NEW_SOURCE
            updated = True
            print("Updated 'main-pipeline' cell.")
            break
            
    if not updated:
        print("Warning: Cell with id 'main-pipeline' not found. Appending new cell.")
        nb["cells"].append({
            "cell_type": "code",
            "execution_count": None,
            "id": "main-pipeline",
            "metadata": {},
            "source": NEW_SOURCE
        })

    with open(NOTEBOOK_PATH, "w", encoding="utf-8") as f:
        json.dump(nb, f, indent=1, ensure_ascii=False)
    print("Notebook saved.")

if __name__ == "__main__":
    main()
