---
description: Основные инструкции для AI-агента при работе с проектом
---

# Общие правила

1. **Язык ответов** — всегда отвечай на русском языке
2. **Автотесты** — генерируй unit-тесты при решении задач (pytest)
3. **Документация** — обновляй README.md и docs/ при изменении функционала
4. **Changelog** — заноси все изменения в CHANGELOG.md в секцию [Unreleased]
5. **Версионирование** — при релизе обновляй VERSION и создавай git tag
6. **Бизнес-объяснения** — при технических вопросах, требующих решения пользователя (product manager), объясняй в терминах пользовательских кейсов и бизнес-воркфлоу, а не в терминах кода

# Обязательный анализ реальных данных

> [!CAUTION]
> **НЕ предлагай решения без анализа реальных метрик!**

## Источники реальных данных:
1. **DB snapshots** — слепки продакшн БД (`db_prod_snapshot.sqlite`, `tmp_db*.sqlite`)
2. **Логи прода** — `flyctl logs -a events-bot-new-wngqia`
3. **JobOutbox** — анализ очереди задач, их статусов и времени выполнения

## Процесс анализа:
1. **Сначала метрики** — извлеки данные из логов/БД (интервалы, ошибки, объёмы)
2. **Потом гипотезы** — формулируй на основе данных, не гадай
3. **Тесты из реальных данных** — создавай моки на основе реальных записей из БД

## Инструкции для Codex:
- При анализе проси Codex смотреть реальные файлы и слепки БД
- После серии коротких exec — проси Codex сделать **комплексный анализ своих артефактов** (не перезапускай всё)
- Codex должен предлагать автотесты с моками из реальных данных

# Git workflow: ветка dev

> ⚠️ **ВАЖНО**: Все изменения сначала коммитятся в ветку `dev`, а не в `main`!

## Автоматические коммиты в dev

После каждого завершённого исправления или добавления функционала:

1. Переключись на ветку `dev` (создай если не существует):
   ```bash
   git checkout dev 2>/dev/null || git checkout -b dev
   ```

2. Закоммить изменения с понятным сообщением:
   ```bash
   git add -A && git commit -m "тип: краткое описание"
   ```
   Типы: `fix`, `feat`, `refactor`, `docs`, `test`, `chore`

3. Запуш в remote для сохранности:
   ```bash
   git push origin dev
   ```

Это гарантирует, что код не потеряется даже при недоступности codespace.

## При релизе на прод

Ветка `dev` мержится в `main` только при команде `/release`:

1. Переключись на main: `git checkout main`
2. Смерж dev: `git merge dev`
3. Выполни шаги релиза (см. ниже)
4. После успешного релиза можно удалить dev: `git branch -d dev`

# Версионирование (SemVer)

Формат: `MAJOR.MINOR.PATCH`

- **MAJOR** — несовместимые изменения API, крупные рефакторинги
- **MINOR** — новый функционал с сохранением совместимости
- **PATCH** — багфиксы и мелкие улучшения

## Обязательные шаги при релизе на прод:

1. Определи тип изменений (major/minor/patch)
2. Обнови файл `VERSION` с новой версией
3. Перенеси секцию [Unreleased] в CHANGELOG → `[X.Y.Z] – YYYY-MM-DD`
4. Создай новую пустую секцию [Unreleased]
5. Закоммить все изменения: `git add -A && git commit -m "chore: release vX.Y.Z"`
6. **Создай git tag**: `git tag -a vX.Y.Z -m "Release vX.Y.Z"`
7. **Запуш с тегами**: `git push origin main --tags`
8. **Деплой на Fly.io**: `fly deploy` (ТОЛЬКО ПО КОМАНДЕ ПОЛЬЗОВАТЕЛЯ!)

> ⚠️ **ВАЖНО**: Git tag ОБЯЗАТЕЛЕН! Без тега релиз не считается завершённым.

# Структура проекта

- `video_announce/` — видео-анонсы (сессии, паттерны, превью)
- `kaggle/VideoAfisha/` — Kaggle notebook для рендеринга
- `docs/` — документация проекта
- `tests/` — автотесты (pytest)

# Работа с Codex API (Smart Assistant)

Используй `codex exec` для сложных инженерных задач. Codex — это умный помощник-архитектор.

## Обязательный паттерн вызова Codex

> [!IMPORTANT]
> **Всегда вызывай Codex так, чтобы:**
> 1. Пользователь видел терминал с выводом Codex
> 2. Результаты записывались в файл
> 3. Были видны промежуточные итерации

### Стандартный шаблон вызова:
```bash
mkdir -p .codex/reports
codex exec -m gpt-5.2-codex --sandbox workspace-write -o .codex/reports/<task_name>.md \
  "Работай по фазам. После каждой фазы запиши промежуточный отчёт. <ЗАДАЧА>"
```

### Модели Codex
Переключай модель через флаг `-m`:

| Модель | Назначение |
|--------|------------|
| `gpt-5.2-codex` | **Основная** для работы с кодом (default) |
| `gpt-5.1-codex-max` | Flagship для глубокого reasoning |
| `gpt-5.1-codex-mini` | Дешевле, быстрее, менее способная |
| `gpt-5.2` | Архитектор и UI (без приставки codex) |

> [!CAUTION]
> НЕ используй модели `o3`, `gpt-4o` и другие — только модели из таблицы выше!

## Сценарии использования:

1. **Архитектура и Дизайн**:
   - Планирование модулей: `codex exec --full-auto "спроектируй структуру модуля видео-рендеринга"`
   - Анализ зависимостей: `codex exec "проанализируй циклические импорты в main.py"`

2. **Автотесты (QA)**:
   - Генерируй тесты для сложной логики: `codex exec --sandbox workspace-write "напиши тесты для month_split на граничных условиях"`
   - Проверяй покрытие: `codex exec "какие кейсы не покрыты тестами в parser.py?"`

3. **Code Review**:
   - Перед коммитом: `codex exec "проведи ревью изменений, найди уязвимости и race conditions"`
   - Оптимизация: `codex exec "предложи оптимизацию SQL запросов в db.py"`

4. **Планирование задач**:
   - Codex может генерировать план работ:
     ```bash
     codex exec -o task_draft.md "проанализируй Issue #123 и составь пошаговый план implementation_plan.md"
     ```
   - Затем ты можешь использовать этот план для выполнения задачи.

> **Совет**: Используй `--full-auto` для задач, где Codex должен сам искать файлы и править их. Используй `--sandbox danger-full-access` только для глобальных рефакторингов.

## Паттерны видимости прогресса Codex
> [!IMPORTANT]
> Codex НЕ стримит промежуточные результаты в stdout. Для длинных задач используй один из паттернов:

### Паттерн 1: Чекпойнты в файлы (рекомендуется)
```bash
mkdir -p .codex/reports
codex exec --sandbox workspace-write \
  "Работай по фазам. После каждой фазы запиши отчёт в .codex/reports/PHASE-<n>.md"
```
Мониторинг: `ls -lt .codex/reports`

### Паттерн 3: Серия коротких exec (для оркестрации)
```bash
codex exec -o .codex/01-analysis.md "Проанализируй проблему."
codex exec -o .codex/02-plan.md     "Составь план работ."
codex exec -o .codex/03-proposal.md "Дай рекомендации."
```
Так ты видишь результат после каждого шага и можешь скорректировать курс.

## Взаимодействие с Codex (Senior Assistant)
1.  **Роль**: Codex — твой старший помощник. Его мнение критически важно.
2.  **Время работы**: Codex работает на максимальной модели и может думать долго. **Никогда не ограничивай его во времени.** Всегда дожидайся результата, даже если это занимает минуты.
3.  **Диалог**: Веди с Codex интерактивный диалог. Если Codex задает вопросы — отвечай или собирай их в документ для пользователя.
4.  **Совместная работа**: Если пользователь попросил подключить Codex, ты обязан получить от него полный анализ и ответы перед принятием решений.

## Отчетность по Codex
Если в решении задачи применялся Codex, в финальном ответе пользователю **обязательно** укажи:
1.  **Зоны ответственности**: Какую часть задачи решил Codex (анализ, генерация кода, тесты).
2.  **Метрики**: Сколько итераций или команд потребовалось.
3.  **Результат**: Как сработала мультиагентская схема. Если Codex работал долго — это нормально, укажи это.

# Работа с временными скриптами

1. **Изоляция** — все временные скрипты для миграции, диагностики или чистки данных должны находиться в папке `scripts/`. НЕ захламляй корень проекта.
2. **Имя файла** — используй префикс `tmp_` и говорящее название: `tmp_fix_muz_desc.py`, `tmp_check_sobor_text.py` и т.д. Это упростит их поиск и удаление через `rm scripts/tmp_*`.
3. **Очистка** — после успешного выполнения на продакшене удаляй скрипты из репозитория, если они не несут долгосрочной ценности.
4. **Безопасность** — всегда предусматривай "сухой запуск" (dry run) или подтверждение изменений для скриптов, меняющих данные.

# Инструкции для Antigravity:
- Ты отвечаешь за инфраструктуру, диагностику и подготовку данных.
- Исправления в **основной программный код** (бизнес-логика, парсеры, бот) должен вносить только агент **Codex**. Ты можешь подготовить для него почву, провести расследование и составить ТЗ.
