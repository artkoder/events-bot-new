import json
import os

notebook_content = {
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Intelligent Telegram Channel Monitor\n",
    "\n",
    "This notebook monitors Telegram channels for events, analyzes them with Gemma, and deduplicates against existing Telegraph pages."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install -q telethon emoji python-dotenv google-generativeai requests beautifulsoup4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import json\n",
    "import time\n",
    "import random\n",
    "import asyncio\n",
    "import requests\n",
    "from telethon import TelegramClient\n",
    "from telethon.sessions import StringSession\n",
    "from telethon.tl.types import MessageMediaPhoto\n",
    "import google.generativeai as genai\n",
    "from bs4 import BeautifulSoup\n",
    "\n",
    "# === Configuration ===\n",
    "# Secrets should be passed via Kaggle Secrets\n",
    "TG_SESSION = os.environ.get('TG_SESSION') or 'YOUR_SESSION_STRING_HERE'\n",
    "API_ID = os.environ.get('TG_API_ID')\n",
    "API_HASH = os.environ.get('TG_API_HASH')\n",
    "GEMMA_API_KEY = os.environ.get('GEMMA_API_KEY')\n",
    "\n",
    "# Context from Server (Mock for now, should be injected)\n",
    "TELEGRAPH_URLS = os.environ.get('TELEGRAPH_URLS', '').split(',')\n",
    "CHANNELS = os.environ.get('CHANNELS', '').split(',')\n",
    "\n",
    "if not TG_SESSION or not API_ID or not API_HASH:\n",
    "    raise ValueError(\"Missing Telegram credentials\")\n",
    "\n",
    "genai.configure(api_key=GEMMA_API_KEY)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Helper Functions ===\n",
    "\n",
    "def get_telegraph_context(urls):\n",
    "    \"\"\"Fetches text content from Telegraph pages to build context for deduplication.\"\"\"\n",
    "    context_text = \"\"\n",
    "    for url in urls:\n",
    "        if not url: continue\n",
    "        try:\n",
    "            resp = requests.get(url)\n",
    "            soup = BeautifulSoup(resp.content, 'html.parser')\n",
    "            article = soup.find('article')\n",
    "            if article:\n",
    "                context_text += article.get_text(separator='\\n') + \"\\n---\\n\"\n",
    "        except Exception as e:\n",
    "            print(f\"Error fetching {url}: {e}\")\n",
    "    return context_text\n",
    "\n",
    "def upload_to_catbox(file_path):\n",
    "    \"\"\"Uploads image to Catbox.moe\"\"\"\n",
    "    try:\n",
    "        with open(file_path, 'rb') as f:\n",
    "            response = requests.post(\n",
    "                'https://catbox.moe/user/api.php',\n",
    "                data={'reqtype': 'fileupload'},\n",
    "                files={'fileToUpload': f}\n",
    "            )\n",
    "            if response.status_code == 200:\n",
    "                return response.text\n",
    "    except Exception as e:\n",
    "        print(f\"Catbox upload failed: {e}\")\n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Gemma Logic ===\n",
    "\n",
    "def analyze_event_gemma(text):\n",
    "    \"\"\"Analyzes if text is an event.\"\"\"\n",
    "    model = genai.GenerativeModel('gemini-2.0-flash-exp') # Or appropriate model\n",
    "    prompt = f\"\"\"\n",
    "    Analyze the following text. Is it an event announcement?\n",
    "    If YES, extract: Title, Date, Time, Location, Short Description.\n",
    "    If NO, return strict JSON: {{\"is_event\": false}}\n",
    "    If YES, return strict JSON: {{\"is_event\": true, \"title\": \"...\", \"date\": \"YYYY-MM-DD\", \"time\": \"HH:MM\", \"location\": \"...\", \"description\": \"...\"}}\n",
    "    \n",
    "    Text:\n",
    "    {text}\n",
    "    \"\"\"\n",
    "    try:\n",
    "        response = model.generate_content(prompt)\n",
    "        # Clean format (markdown json code blocks)\n",
    "        cleaned = response.text.replace('```json', '').replace('```', '')\n",
    "        return json.loads(cleaned)\n",
    "    except Exception as e:\n",
    "        print(f\"Gemma analysis error: {e}\")\n",
    "        return None\n",
    "\n",
    "def check_duplicate_gemma(new_event, context_text):\n",
    "    \"\"\"Checks for duplicates against context.\"\"\"\n",
    "    model = genai.GenerativeModel('gemini-2.0-flash-exp')\n",
    "    prompt = f\"\"\"\n",
    "    Existing Events Context:\n",
    "    {context_text}\n",
    "    \n",
    "    New Event to Check:\n",
    "    Title: {new_event.get('title')}\n",
    "    Date: {new_event.get('date')}\n",
    "    Location: {new_event.get('location')}\n",
    "    \n",
    "    Task: Is this new event ALREADY present in the Exisiting Events Context? \n",
    "    Compare usually fuzzy matching on title, date and location.\n",
    "    Return strict JSON: {{\"is_duplicate\": true/false, \"reason\": \"...\"}}\n",
    "    \"\"\"\n",
    "    try:\n",
    "        response = model.generate_content(prompt)\n",
    "        cleaned = response.text.replace('```json', '').replace('```', '')\n",
    "        return json.loads(cleaned)\n",
    "    except Exception as e:\n",
    "        print(f\"Gemma deduplication error: {e}\")\n",
    "        return {\"is_duplicate\": False} # Fail open safe? Or fail closed?\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Main Telethon Loop ===\n",
    "\n",
    "async def main():\n",
    "    results = []\n",
    "    context_text = get_telegraph_context(TELEGRAPH_URLS)\n",
    "    print(\"Context loaded, length:\", len(context_text))\n",
    "\n",
    "    # Spoofing Params\n",
    "    device_config = {\n",
    "        'device_model': 'Samsung S22 Ultra',\n",
    "        'system_version': '13.0',\n",
    "        'app_version': '9.6.6'\n",
    "    }\n",
    "\n",
    "    async with TelegramClient(StringSession(TG_SESSION), int(API_ID), API_HASH, **device_config) as client:\n",
    "        for channel in CHANNELS:\n",
    "            if not channel: continue\n",
    "            print(f\"Scanning {channel}...\")\n",
    "            try:\n",
    "                # Get last 10 messages or N hours\n",
    "                async for message in client.iter_messages(channel, limit=10):\n",
    "                    if not message.text: continue\n",
    "                    \n",
    "                    print(f\"Processing message {message.id}...\")\n",
    "                    \n",
    "                    # 1. Analyze\n",
    "                    analysis = analyze_event_gemma(message.text)\n",
    "                    if not analysis or not analysis.get('is_event'):\n",
    "                        print(\"  -> Not an event\")\n",
    "                        continue\n",
    "                    \n",
    "                    # 2. Deduplicate\n",
    "                    dedup = check_duplicate_gemma(analysis, context_text)\n",
    "                    if dedup.get('is_duplicate'):\n",
    "                        print(\"  -> Duplicate detected:\", dedup.get('reason'))\n",
    "                        continue\n",
    "                    \n",
    "                    # 3. Media\n",
    "                    catbox_url = None\n",
    "                    if message.media and isinstance(message.media, MessageMediaPhoto):\n",
    "                        path = await message.download_media(file=\"tmp_img\")\n",
    "                        catbox_url = upload_to_catbox(path)\n",
    "                        if os.path.exists(path): os.remove(path)\n",
    "                    \n",
    "                    # 4. Result\n",
    "                    results.append({\n",
    "                        \"status\": \"new\",\n",
    "                        \"source_link\": f\"https://t.me/{channel}/{message.id}\",\n",
    "                        \"original_text\": message.text,\n",
    "                        \"catbox_url\": catbox_url,\n",
    "                        \"extracted_data\": analysis\n",
    "                    })\n",
    "                    \n",
    "                    # Rate limit kindness\n",
    "                    await asyncio.sleep(random.uniform(2, 5))\n",
    "                    \n",
    "            except Exception as e:\n",
    "                print(f\"Error scanning {channel}: {e}\")\n",
    "    \n",
    "    # Save Results\n",
    "    with open('telegram_results.json', 'w', encoding='utf-8') as f:\n",
    "        json.dump(results, f, ensure_ascii=False, indent=2)\n",
    "    print(f\"Done. Found {len(results)} new events.\")\n",
    "\n",
    "# Run\n",
    "# await main() # In notebook, await main() works if top-level await is enabled, or asyncio.run(main())\n",
    "# Since this is a script generator, we put the call in the cell source\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import asyncio\n",
    "try:\n",
    "    loop = asyncio.get_running_loop()\n",
    "except RuntimeError:\n",
    "    loop = asyncio.new_event_loop()\n",
    "    asyncio.set_event_loop(loop)\n",
    "\n",
    "loop.run_until_complete(main())"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

with open('kaggle/TelegramMonitor/telegram_monitor.ipynb', 'w') as f:
    json.dump(notebook_content, f, indent=1)
