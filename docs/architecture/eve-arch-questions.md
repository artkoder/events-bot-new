# EVE Frameworks — Фаза 3 (Вопросы к владельцу продукта)

Цель: снять неопределённости, которые влияют на выбор между SDK/gateway, на схему данных и на гарантии “без гонок” / “без утечек ключей”.

## A) Kaggle и секреты (EVE-54)

1) **Должны ли Kaggle-ноутбуки делать *прямые* вызовы Google AI, или можно/нужно ходить через gateway?**
- Варианты:
  - A: Только gateway (Kaggle не хранит Google API keys).
  - B: Прямые вызовы из Kaggle (тогда нужно безопасно доставлять *пул* ключей и всё равно координировать лимиты через Supabase).
  - C: Гибрид: Kaggle через gateway, бот/сервисы — SDK.

2) **Есть ли у Kaggle гарантированный исходящий доступ в интернет к вашему домену/инфре (gateway) и/или к Supabase?**
- Варианты:
  - A: Да, без ограничений.
  - B: Да, но только к Supabase.
  - C: Нет/нестабильно (тогда gateway/Supabase-координация может быть ограничена).

3) **Допустимо ли хранить Google API keys в Supabase (как секреты/в vault), или принципиально “ключи только вне БД”?**
- Сейчас `google_ai_api_keys.env_var_name` намекает на подход “ключи в окружении, в БД только метаданные”.
- Если ключи *не* в Supabase: кто должен иметь доступ ко *всем* ключам пула (бот? gateway? Kaggle?).

4) **Какой механизм аутентификации/авторизации предполагается для клиентов (если будет gateway)?**
- Примеры: статический токен, HMAC подпись, JWT, allowlist IP (вряд ли для Kaggle), Supabase auth.

## B) Семантика лимитов и “account_name” (EVE-11)

5) **Лимиты считаются “на ключ”, “на аккаунт Google”, или “на проект/биллинг-аккаунт”?**
- В задаче упоминается `GOOGLE_API_LOCALNAME` и “лимит считается по конкретному аккаунту”.
- Нужно понять: один `api_key` = один аккаунт? или несколько ключей могут быть в одном аккаунте и должны делить лимит?

6) **Кто задаёт `account_name`/`GOOGLE_API_LOCALNAME`: вызывающий сервис или система должна выводить его из `api_key_id`?**
- Варианты:
  - A: клиент всегда передаёт `account_name` (и ответственность на нём).
  - B: `account_name` = `google_ai_api_keys.key_alias` / `provider-account`, выбирается внутри reserve.

7) **Какой TZ использовать для суточного окна `RPD`: UTC или “время аккаунта/региона”?**
- Рекомендация по умолчанию: UTC, но важно подтвердить.

## C) Модельные идентификаторы (EVE-55)

8) **Какие именно строки `model` считаются “каноническими” для БД и логов?**
- В коде Kaggle сейчас встречаются:
  - `"gemma-3-27b-it"` (передаётся как `model`, затем используется как `models/{model}`),
  - `"gemma-3-27b"` (в логах `LLMLogger`).
- В таблице `google_ai_model_limits.model` предполагается что-то вроде `"gemma-3-27b"` / `"gemini-2.5-flash"`.
- Нужно решить: хранить “короткий” id (`gemma-3-27b`) или “полный” провайдерный (`models/gemma-3-27b-it`), и как делать маппинг.

9) **Нужно ли поддержать одновременно Gemma и Gemini сразу в первой итерации, или достаточно Gemma → потом Gemini?**

## D) Planned tokens / max_output и извлечение usage

10) **Откуда берём `planned_tokens`?**
- Варианты:
  - A: клиент передаёт `planned_input_tokens` и `planned_max_output_tokens`.
  - B: система сама считает (нужна функция token counting, либо грубая оценка).
- Важно для TPM: если planned занижен, можно превысить TPM постфактум.

11) **Ожидаем ли, что Google SDK всегда возвращает usage токены?**
- Если нет — какая политика “fallback”: считать planned фактом или помечать `actual_unknown` и делать отдельный reconcile?

## E) Схема Supabase и индексы

12) **Есть ли уже реальные SQL-миграции/описание индексов для `google_ai_*` таблиц (не только скриншот)?**
- Особенно важно для `google_ai_usage_counters`: нужны уникальные ключи/индексы для atomic upsert.

13) **Как именно должен интерпретироваться `google_ai_usage_counters.rpd_used` при наличии `minute_bucket` и `day_bucket` в одной строке?**
- Варианты:
  - A: `rpd_used` — дневной счётчик, храним отдельной строкой/таблицей (тогда нужен иной ключ/nullable minute_bucket).
  - B: `rpd_used` — кумулятивный дневной счётчик “на текущую минуту” (тогда нужен механизм переносов/копирования между минутными строками).
  - C: схема подлежит изменению (разнести minute/day в 2 таблицы).

14) **Можно ли добавлять новые таблицы для идемпотентности и аудита?**
- Например `google_ai_requests` (reservations, `request_uid`, статус) и/или `google_ai_usage_events` (attempt-level лог).

## F) Ретраи, WAIT/NO_WAIT и эксплуатационные параметры

15) **Нужны ли ретраи только на провайдерные ошибки, или также на временную блокировку по минутному лимиту (WAIT)?**
- Как сочетаются “макс 3 ретрая” с WAIT-режимом (ожидание до окна) — считать ли ожидание “ретраем”?

16) **Максимальное время ожидания в `WAIT` режиме (`max_wait_ms`) и политика jitter/backoff?**
- Рекомендация: добавить jitter на границе минуты, но важно согласовать величины.

17) **Что делать при “дневном блоке” (`RPD`):**
- A: всегда ошибка без ожидания;
- B: ожидать до смены суток (обычно непрактично), но можно для batch.

## 7) Промежуточный отчёт (Фаза 3)

Подготовлены вопросы, которые:
- определяют выбор между SDK/gateway и допустимую модель безопасности для Kaggle;
- проясняют семантику `account_name`/`GOOGLE_API_LOCALNAME` и model id;
- закрывают критичную неопределённость схемы `google_ai_usage_counters` и необходимость доп. таблиц для идемпотентности/аудита;
- задают эксплуатационные параметры (`WAIT`, ретраи, TZ для RPD).

