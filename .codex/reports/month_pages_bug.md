Проверил логику по коду.

- `schedule_event_update_tasks` в `main.py:10128` всегда ставит `month_pages` для месяца события (`month = ev.date.split("..", 1)[0][:7]`) и вызывает `enqueue_job`, который коалесцирует только по этому месяцу. Для разных месяцев должны быть разные `coalesce_key` (`month_pages:YYYY-MM`).
- `source_parsing/handlers.py:403` вызывает `schedule_event_update_tasks` для каждого сохранённого события (без условий по `was_added`), так что `/parse` должен поставить задачу для каждого месяца отдельно.
- Доп. блоки “new month” в `schedule_event_update_tasks` могут ставить задачи для других месяцев, но они ничего не отменяют и не пропускают текущий месяц.

**Вывод**
Нет, по коду это не выглядит как “если много месяцев — часть не ставится”. Если нет `month_pages:2025-12`, значит либо декабрьское событие не дошло до `schedule_event_update_tasks`, либо его `Event.date` не начинается с `2025-12` (ошибка/формат парсинга), либо логи обрезаны. Я бы проверил `Event.date` у декабрьских событий и наличие `JobOutbox` с `coalesce_key = month_pages:2025-12`.

Если нужно усилить надёжность, варианты фикса:
1. В `schedule_event_update_tasks` вычислять месяц через `parse_iso_date` и логировать/отбрасывать некорректные даты (сейчас просто `[:7]`).
2. В `/parse` собирать уникальные месяцы по всем событиям и после обработки вызвать `enqueue_job` один раз на месяц (исключает пропуски из‑за нестандартного формата даты).
3. Если события могут переходить через границу месяца, дополнительно ставить `month_pages` для `end_date` (если он есть и месяц отличается).