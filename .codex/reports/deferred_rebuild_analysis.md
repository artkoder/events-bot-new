**Фаза 1**
- `enqueue_job` кладет `next_run_at` в `run_time` и пишет его в `JobOutbox.next_run_at` при создании новой задачи, так что отложенные задачи должны оставаться в будущем по умолчанию (`main.py:9896`, `main.py:10102`).
- Для уже существующей `pending`‑задачи `next_run_at` сохраняется, если он в будущем, иначе сбрасывается на `now`, так что отложенность сохраняется при слиянии (`main.py:9971`, `main.py:9981`).
- Для `running`‑задачи время не сдвигается; отложенная “копия” создается только если владелец другой (`main.py:10002`, `main.py:10020`, `main.py:10034`).
- Промежуточный отчет: `enqueue_job` уважает `next_run_at` для новых/`pending` задач, но не может отложить уже `running` и создает отдельную deferred‑задачу только при другом владельце.

**Фаза 2**
- В `schedule_event_update_tasks` действительно задается отложенный запуск для `month_pages` и `weekend_pages`, тогда как `week_pages` и `festival_pages` остаются немедленными (`main.py:10138`, `main.py:10144`, `main.py:10150`, `main.py:10156`, `main.py:10160`).
- В `_drain_nav_tasks` все выборки “что осталось” фильтруются `next_run_at <= now`, то есть отложенные задачи должны игнорироваться (`main.py:10227`, `main.py:10237`, `main.py:10284`, `main.py:10318`).
- Но когда “слияние” завершилось, `_drain_nav_tasks` создает follow‑up без `next_run_at`, то есть сразу (`main.py:10289`, `main.py:10301`).
- Промежуточный отчет: дефёр в `schedule_event_update_tasks` есть, но `_drain_nav_tasks` умеет порождать немедленную follow‑up задачу, обходя отложенность.

**Фаза 3**
- `_run_due_jobs_once` выбирает только `pending/error` с `next_run_at <= now`, так что будущие задачи не должны исполняться (`main.py:11608`, `main.py:11612`).
- Все вызовы проходят через эту фильтрацию: `_drain_nav_tasks`, фоновый воркер, ручной прогон и прогресс‑луп (`main.py:10216`, `main.py:12017`, `main.py:12070`, `main.py:13433`).
- Значит, немедленный запуск возможен только если конкретная задача реально оказалась с `next_run_at <= now`.
- Промежуточный отчет: ранний запуск не из‑за `_run_due_jobs_once`, а из‑за того, что задача попала в очередь как “due”.

**Фаза 4**
- Конкретная причина: если в момент добавления события уже есть `month/week/weekend/festival` задача того же `coalesce_key` у другого владельца и она “due”, `_drain_nav_tasks` после дренажа создает follow‑up без `next_run_at`, что делает ее немедленной и запускает в той же петле, несмотря на исходный дефёр (`main.py:10289`, `main.py:10301`).
- Дополнительный обход дефёра: если coalesce‑задача уже `running` (особенно у того же `event_id`), `enqueue_job` не пересчитывает `next_run_at`, так что выполняется текущий прогон сразу, а не через 15 минут (`main.py:10002`, `main.py:10020`).
- Логи “fest link” соответствуют рендеру месячных страниц с фестивальными ссылками; это согласуется с немедленным запуском `month_pages` (`main_part2.py:75`, `main_part2.py:83`).
- Промежуточный отчет: дефёр обходится из‑за follow‑up в `_drain_nav_tasks` (и/или уже запущенного coalesce‑джоба), поэтому страницы пересобираются сразу.

Если нужно, могу предложить конкретный патч: передавать `next_run_at=deferred_time` при follow‑up в `_drain_nav_tasks` или пропускать follow‑up при активной отложенной задаче для `event_id`.