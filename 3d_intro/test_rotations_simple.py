#!/usr/bin/env python3
"""
Quick test of 4 rotation variants for front texture only
Uses existing texture generation and rotates in PIL before loading
"""

import bpy
import os
import sys
from PIL import Image

sys.path.insert(0, "/workspaces/events-bot-new/3d_intro")

OUTPUT_DIR = "/workspaces/events-bot-new/3d_intro/assets"
TEXTURE_DIR = "/tmp/scene_textures"


def clean_scene():
    bpy.ops.wm.read_factory_settings(use_empty=True)


def load_image_texture(image_path: str):
    if os.path.exists(image_path):
        return bpy.data.images.load(image_path)
    return None


def create_material(name: str, texture):
    mat = bpy.data.materials.new(name=name)
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    nodes.clear()
    
    bsdf = nodes.new(type='ShaderNodeBsdfPrincipled')
    bsdf.inputs['Base Color'].default_value = (1, 1, 1, 1)
    bsdf.inputs['Roughness'].default_value = 0.3
    bsdf.inputs['Specular IOR Level'].default_value = 0.0
    
    if texture:
        tex_image = nodes.new(type='ShaderNodeTexImage')
        tex_image.image = texture
        links.new(tex_image.outputs['Color'], bsdf.inputs['Base Color'])
    
    output = nodes.new(type='ShaderNodeOutputMaterial')
    links.new(bsdf.outputs['BSDF'], output.inputs['Surface'])
    
    return mat


def test_rotation(front_rot: int, right_rot: int, output_name: str):
    """Test specific rotation combination"""
    # Load and rotate textures
    front_src = f"{TEXTURE_DIR}/main_front_orig.png"
    right_src = f"{TEXTURE_DIR}/main_right_orig.png"
    
    img_f = Image.open(front_src)
    if front_rot != 0:
        img_f = img_f.rotate(front_rot, expand=True)
    front_path = f"{TEXTURE_DIR}/test_front_{front_rot}.png"
    img_f.save(front_path)
    
    img_r = Image.open(right_src)
    if right_rot != 0:
        img_r = img_r.rotate(right_rot, expand=True)
    right_path = f"{TEXTURE_DIR}/test_right_{right_rot}.png"
    img_r.save(right_path)
    
    # Create scene
    clean_scene()
    
    bpy.ops.mesh.primitive_cube_add(location=(0, 0, 0), size=2)
    cube = bpy.context.object
    
    tex_f = load_image_texture(front_path)
    tex_r = load_image_texture(right_path)
    
    mat_yellow = bpy.data.materials.new(name="Yellow")
    mat_yellow.use_nodes = True
    bsdf = mat_yellow.node_tree.nodes.get("Principled BSDF")
    if bsdf:
        bsdf.inputs["Base Color"].default_value = (0.945, 0.894, 0.294, 1.0)
    
    mat_front = create_material("Front", tex_f)
    mat_right = create_material("Right", tex_r)
    
    cube.data.materials.append(mat_yellow)
    cube.data.materials.append(mat_front)
    cube.data.materials.append(mat_right)
    
    for poly in cube.data.polygons:
        n = poly.normal
        if n[1] < -0.9:
            poly.material_index = 1
        elif n[0] > 0.9:
            poly.material_index = 2
        else:
            poly.material_index = 0
    
    bpy.ops.object.camera_add(location=(4, -4, 0))
    camera = bpy.context.object
    camera.data.type = 'ORTHO'
    camera.data.ortho_scale = 4.5
    
    constraint = camera.constraints.new(type='TRACK_TO')
    constraint.target = cube
    constraint.track_axis = 'TRACK_NEGATIVE_Z'
    constraint.up_axis = 'UP_Y'
    
    bpy.context.scene.camera = camera
    
    bpy.ops.object.light_add(type='SUN', location=(5, -3, 8))
    bpy.context.object.data.energy = 5.0
    
    scene = bpy.context.scene
    if not scene.world:
        scene.world = bpy.data.worlds.new("World")
    scene.world.use_nodes = True
    bg = scene.world.node_tree.nodes.get("Background")
    if bg:
        bg.inputs["Color"].default_value = (0.7, 0.7, 0.7, 1.0)
    
    # Render
    scene.render.resolution_x = 512
    scene.render.resolution_y = 256
    scene.render.engine = 'CYCLES'
    scene.cycles.samples = 16
    scene.cycles.device = 'CPU'
    scene.cycles.use_denoising = False
    scene.render.filepath = f"{OUTPUT_DIR}/{output_name}"
    
    bpy.ops.render.render(write_still=True)
    print(f"Rendered: {output_name}")


if __name__ == "__main__":
    # Assume base textures are already generated by running gen_base_textures.py separately
    
    # Test 4 rotations for right face with front=90 (which works)
    for rot in [0, 90, 180, 270]:
        test_rotation(90, rot, f"rot_right_{rot}.png")
    
    print("\nDone! Check:")
    print("  assets/rot_right_0.png")
    print("  assets/rot_right_90.png") 
    print("  assets/rot_right_180.png")
    print("  assets/rot_right_270.png")
    
    print("\nDone! Check:")
    print("  assets/rot_front_0.png")
    print("  assets/rot_front_90.png") 
    print("  assets/rot_front_180.png")
    print("  assets/rot_front_270.png")
